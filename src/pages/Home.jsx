import React, { useState, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createWorker } from 'tesseract.js';
import Webcam from 'react-webcam';
import Modal from 'react-modal';
import '../styles/Animations.css';

// Set the app element for react-modal
Modal.setAppElement('#root');

const Home = () => {
  const [image, setImage] = useState(null);
  const [extractedText, setExtractedText] = useState('');
  const [isExtracting, setIsExtracting] = useState(false);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [error, setError] = useState(null);
  const [isCameraOpen, setIsCameraOpen] = useState(false);
  const navigate = useNavigate();
  const fileInputRef = useRef(null);
  const webcamRef = useRef(null);

  const handleDrop = (e) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    handleFile(file);
  };

  const handleFileInput = (e) => {
    const file = e.target.files[0];
    handleFile(file);
  };

  const handleFile = async (file) => {
    if (file && file.type.startsWith('image/')) {
      setImage(URL.createObjectURL(file));
      setIsExtracting(true);
      try {
        const text = await extractTextFromImage(file);
        setExtractedText(text);
        console.log('Extracted text:', text);
      } catch (error) {
        setError('Error extracting text from image');
        console.error('Text extraction error:', error);
      }
      setIsExtracting(false);
    } else {
      setError('Please upload an image file');
    }
  };

  const extractTextFromImage = async (file) => {
    setIsExtracting(true);
    setError(null);
    try {
      const worker = await createWorker('eng');
      const { data: { text } } = await worker.recognize(file);
      await worker.terminate();
      setExtractedText(text);
    } catch (err) {
      console.error('Error extracting text:', err);
      setError('Failed to extract text from the image. Please try again.');
    } finally {
      setIsExtracting(false);
    }
  };

  const handleSubmit = async () => {
    const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    if (!apiKey) {
      setError('API key is not set. Please check your environment variables.');
      console.error('API key is not set');
      return;
    }

    setIsAnalyzing(true);
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: "gemini-pro" });

    const prompt = `This is generated by OCR AI from an image taken from the back of the product. Please provide the ingredients in the following JSON format:
    {
      "ingredients": [
        {
          "ingredient": "<ingredient_name>",
          "ingredientDescription": "<description_of_ingredient>",
          "rating": <rating_from_1_to_10>,
          "threat": <true_or_false>
        }
      ]
    }
    
    **Details:**
    - **ingredient**: The name of the ingredient.
    - **ingredientDescription**: A description of the ingredient.
    - **rating**: A number from 1 to 10 indicating how dangerous the ingredient is, with 1 being the least dangerous and 10 being the most.
    - **threat**: Boolean value indicating whether the ingredient is harmful (true) or not (false).
    
    Please ensure the response is a valid JSON string with the exact format shown above. If the response is not in the correct JSON format, return an empty JSON object ({}).
    
    Extracted text: ${extractedText}`;

    try {
      console.log('Sending prompt to Gemini API:', prompt);
      const result = await model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      console.log('Gemini API response:', text);
      const parsedIngredients = JSON.parse(text);
      console.log('Parsed ingredients:', parsedIngredients);
      navigate('/ingredients', { state: { ingredients: parsedIngredients } });
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      setError('An error occurred while processing the ingredients');
    } finally {
      setIsAnalyzing(false);
    }
  };

  const openCamera = () => {
    setIsCameraOpen(true);
    setError(null);
  };

  const closeCamera = () => {
    setIsCameraOpen(false);
  };

  const captureImage = useCallback(() => {
    const imageSrc = webcamRef.current.getScreenshot();
    if (imageSrc) {
      setImage(imageSrc);
      setIsCameraOpen(false);

      // Convert base64 to blob
      fetch(imageSrc)
        .then(res => res.blob())
        .then(blob => {
          const file = new File([blob], 'captured-image.jpg', { type: 'image/jpeg' });
          extractTextFromImage(file);
        })
        .catch(err => {
          console.error('Error processing captured image:', err);
          setError('Failed to process the captured image. Please try again.');
        });
    }
  }, [webcamRef]);

  const videoConstraints = {
    width: 1280,
    height: 720,
    facingMode: 'environment'
  };

  return (
    <div className="flex-grow relative min-h-screen">
      <div className="animated-background"></div>
      <div className="relative z-10 py-8">
        <div className="max-w-2xl mx-auto bg-white bg-opacity-80 backdrop-blur-sm rounded-lg shadow-lg p-8">
          <h1 className="text-3xl font-bold mb-6 text-center text-emerald-700">Analyze Product Ingredients</h1>
          <div
            onDrop={handleDrop}
            onDragOver={(e) => e.preventDefault()}
            className="border-4 border-dashed border-emerald-200 rounded-lg p-8 mb-6 text-center cursor-pointer bg-emerald-50 bg-opacity-50"
          >
            {image ? (
              <img src={image} alt="Captured" className="max-w-full h-auto mx-auto" />
            ) : (
              <p className="text-emerald-700">Drag and drop an image here, or click to select a file</p>
            )}
            <input
              type="file"
              accept="image/*"
              onChange={handleFileInput}
              className="hidden"
              ref={fileInputRef}
            />
          </div>
          <div className="flex justify-center space-x-4 mb-6">
            <button
              onClick={() => fileInputRef.current.click()}
              className="bg-emerald-500 text-white px-4 py-2 rounded hover:bg-emerald-600 transition-colors"
            >
              Select Image
            </button>
            <button
              onClick={openCamera}
              className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition-colors"
            >
              Open Camera
            </button>
          </div>
          {error && <p className="text-red-500 mb-4">{error}</p>}
          {isExtracting && (
            <div className="mb-4">
              <p className="text-center mb-2 text-emerald-700">Extracting text from image...</p>
              {/* Add a loading spinner here if you have one */}
            </div>
          )}
          {extractedText && (
            <div className="mb-6">
              <h2 className="text-xl font-semibold mb-2 text-emerald-700">Extracted Text:</h2>
              <textarea
                value={extractedText}
                onChange={(e) => setExtractedText(e.target.value)}
                className="w-full h-32 p-2 border border-emerald-300 rounded focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
              />
            </div>
          )}
          <button
            onClick={handleSubmit}
            disabled={!extractedText || isAnalyzing}
            className="w-full bg-emerald-500 text-white py-2 rounded disabled:bg-gray-300 relative hover:bg-emerald-600 transition-colors"
          >
            {isAnalyzing ? 'Analyzing...' : 'Analyze Ingredients'}
          </button>
        </div>
      </div>
      <Modal
        isOpen={isCameraOpen}
        onRequestClose={closeCamera}
        contentLabel="Camera Modal"
        className="modal"
        overlayClassName="overlay"
      >
        <div className="flex flex-col items-center">
          <Webcam
            audio={false}
            ref={webcamRef}
            screenshotFormat="image/jpeg"
            videoConstraints={videoConstraints}
            className="w-full h-auto"
          />
          <button
            onClick={captureImage}
            className="bg-blue-500 text-white px-4 py-2 rounded mt-4 hover:bg-blue-600 transition-colors"
          >
            Capture Photo
          </button>
          <button
            onClick={closeCamera}
            className="bg-red-500 text-white px-4 py-2 rounded mt-2 hover:bg-red-600 transition-colors"
          >
            Close Camera
          </button>
        </div>
      </Modal>
    </div>
  );
};

export default Home;
